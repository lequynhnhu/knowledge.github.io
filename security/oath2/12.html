<div class="row mt-5 mb-5">
	<div class="col-12">
		<div class="card" id="card">
				<div class="card-body" id="card-body">
						<div class="d-sm-flex justify-content-between align-items-center">
							<h1 class="header-title mb-0">Common OAuth token vulnerabilities</h1>
						</div>
						<div class="market-status-table mt-4">
							<h5>What is a bearer token?</h5>
							</br>
								<p>The OAuth specification defines a bearer token as a security device with the property that any party in possession of the token (a &ldquo;bearer&rdquo;) can use the token, regardless of who that party is. In this way, a bearer token is much like a bus token or a ticket to an amusement park ride: these items grant access to services, and don&rsquo;t care who uses them. As long as you&rsquo;ve got a bus token, you can ride the bus.</p>
								<p>From a technological standpoint, you can think about bearer tokens in much the same way as you do browser cookies. Both share some basic properties:</p>
								<ul>
									<li>They use plaintext strings.</li>
									<li>No secret or signature is involved.</li>
									<li>TLS is the basis of the security model.</li>
								</ul>
								</br>
								<p>But there are some differences:</p>
								<ul>
									<li>Browsers have a long history of dealing with cookies, whereas OAuth clients don&rsquo;t.</li>
									<li>Browsers enforce the same origin policy, meaning that a cookie for one domain isn&rsquo;t passed to another domain. This isn&rsquo;t the case for OAuth clients (and may be a source of problems).</li>
								</ul>
								</br>
								<p>The original OAuth 1.0 protocol called for tokens that also had an associated secret, which was used to calculate a signature across the request. This signature was then veri- fied by the protected resource alongside the token value itself, proving possession of both the token and its associated secret.</p>
								</br>
								<p>Calculating this signature correctly and consis- tently turned out to be a big burden for client and server developers, and the process was prone to many frustrating errors.</p>
								</br>
								<p>Calculating the signature depended on many factors, such as encoding string values, ordering the request parameters, and canoniza- tion of the URI. In combination with the fact that cryptography doesn&rsquo;t forgive even the smallest mistake, things constantly broke because of mismatching signatures.</p>
								</br>
								<p>For instance, a server-side application framework could inject or reorder parame- ters, or a reverse proxy could hide the original request URI from the application doing the OAuth processing.</p>
								<p>One of the authors knows first hand of a developer whose OAuth 1.0 implementation used an uppercase hex encoding on the client side (as %3F, %2D, and %3A), and lowercase hex encoding on the server side (as %3f, %2d, and %3a). This particular implementation bug was infuriating to discover.</p>
								<p>Although a human can easily see these as equivalent, and any machine interpreting the hex value can easily transform it, cryptographic functions require an exact match between both sides in order for the signature to validate properly.</p>						
								</br>
								<p>Furthermore, the requirement for TLS never went away. Without TLS for the get- a-token step, the access token and its secret could be stolen. Without TLS for the use-a-token step, the results of the authorized call could be stolen (and sometimes replayed within a time window). As a result, OAuth 1.0 had the reputation of being a complicated, difficult-to-use protocol.</p>
								<p>The new OAuth 2.0 specification was formed with bearer tokens at the center of a new simplified protocol. Message-level signatures weren&rsquo;t entirely abandoned, but merely set aside. With time, some users of the OAuth 2.0 specification asked for an extension of the protocol that included some sort of sig- nature</p>
								</br>
							<h5>Risks and considerations of using bearer tokens</h5>
							</br>
								<p>Bearer tokens have characteristics similar to the session cookies used in browsers. Unfortunately, misunderstanding this parallelism leads to all sorts of security prob- lems. When an attacker is able to intercept an access token, they are able to access all resources covered by the scope of that particular token.</p>
								</br>
								<p>A client using a bearer token doesn&rsquo;t need to prove possession of any additional security items, such as cryp- tographic key material. Apart from token hijacking (which we&rsquo;ve covered in depth in many parts of this book), the following threats associated with OAuth&rsquo;s bearer tokens are common to many other token-based protocols:</p>
								</br>
								<p><strong>Token forgery.</strong> An attacker may manufacture its own bogus token or modify an existing valid one, causing the resource server to grant inappropriate access to the client. For example, an attacker can craft a token to gain access to informa- tion they weren&rsquo;t able to view before. Alternatively, an attacker could modify the token and extend the validity of the token itself.</p>
								</br>
								<p><strong>Token replay.</strong> An attacker attempts to use an old token that was already used in the past and is supposed to be expired. The resource server shouldn&rsquo;t return any valid data in this case; instead, it should return an error. In a concrete scenario, an attacker legitimately obtains an access token in the first place and they&rsquo;ll try to reuse it long after the token has expired.</p>
								</br>
								<p><strong>Token redirect.</strong> An attacker uses a token generated for consumption by one resource server to gain access to a different resource server that mistakenly believes the token to be valid for it. In this case, an attacker legitimately obtains an access token for a specific resource server and they try to present this access token to a different one.</p>
								</br>
								<p><strong>Token disclosure.</strong> A token might contain sensitive information about the system and the attacker is then something that they couldn&rsquo;t know otherwise. Informa- tion disclosure can be considered a minor problem compared with the previous one, but it&rsquo;s still something we need to care about.</p>
								</br>
							<h5>How to protect bearer tokens</h5>
							</br>
								<p>It is of extreme importance that access tokens sent as bearer tokens are not sent in the clear over an insecure channel. As per the core OAuth specification, transmission of access tokens must be protected using end-to-end confidentiality, such as SSL/TLS.</p>
								</br>
								<p>What is SSL/TLS then? Transport Layer Security (TLS), formerly known as Secure Sockets Layer (SSL), is a cryptographic protocol designed to provide communications security over a computer network. The protocol protects transmissions between two parties directly connected to each other, and the encryption process has the following aspects:</p>
								</br>
								<ul>
									<li>The connection is private because symmetric cryptography is used to encrypt the data transmitted.</li>
									<li>The connection is reliable because each message transmitted includes a message integrity check using a message authentication code.</li>
								</ul>
								</br>
								<p>This is achieved typically by using certificates with public key cryptography; in particu- lar, on the public internet, the application initiating the connection request verifies the certificate of the application receiving the connection request.</p>
								</br>
								<p>In some limited circumstances, the certificate of the application initiating the connection request can also be verified, but such mutual authentication of the TLS connection is fairly limited and rare. It is important to remember that OAuth bearer tokens can&rsquo;t be used securely without TLS being part of the connection in order to protect them in transit.</p>
								</br>
								<h6>At the client</h6>
								</br>
									<p>We&rsquo;ve seen in various parts of this book how access tokens can be stolen from client applications and revealed to the attacker. We need to remember that bearer access tokens are transparent for clients and there isn&rsquo;t any cryptographic operation they need to perform. Hence, when an attacker obtains a bearer access token, they&rsquo;re able to access all the resources associated with the token and its scope.</p>
									</br>
									<p>One countermeasure that a client can apply is to limit the scope of the token to the minimum required for its tasks. For example, if all the client needs to achieve its purpose is the resource owner&rsquo;s profile information, it would be enough to ask for the profile scope (and not any other scope, for example, photo or location).</p>
									</br>
									<p>This approach of &ldquo;minimal privilege&rdquo; limits what the token can be used for if it&rsquo;s captured. To minimize impact on the user experience, a client can ask for all appropriate scopes during the authorization phase, then use the refresh token to get limited-scope access tokens to call the resource directly.</p>
									</br>
									<p>It would also be beneficial, if feasible, to keep access tokens in transient memory to minimize attacks derived from repository injections. Doing so even if the attacker is able to get their hands on the client&rsquo;s database won&rsquo;t gain any information regarding access tokens. This isn&rsquo;t always feasible for all client types, but secure storage of tokens, away from the prying eyes of other applications and even end users, is something that every OAuth client application should be doing.</p>
								</br>
								<h6>At the authorization server</h6>
								</br>
									<p>If an attacker is able to gain access to the authorization server database or launch a SQL injection against it, then the security of multiple resource owners might be compromised. This happens because the authorization server is the central point that coordinates and emits access tokens, issued to multiple clients and potentially consumed by multiple protected resources.</p>
									</br>
									<p>In most implementations, including our own so far, the authorization server stores access tokens in a database. The protected resource validates them upon receipt from a client. This can be achieved in multiple ways but typically a query is launched against the data looking for the matching token.</p>
									</br>
									<p>As one efficient precaution, the authorization server can store hashes of the access token (for example, using SHA-256) instead of the text of the token itself. In this case, even if the attacker was able to steal the entire database containing all the access tokens, there isn&rsquo;t much it can do with the information leaked.</p>
									</br>
									<p>Although hash salting is recommended for storage of user passwords, it should not be required to use addi- tional salt because the access token value should already include a reasonable level of entropy in order to make offline dictionary attacks difficult. For instance, with a random-value token, the token value should be at least 128 bits long and constructed using a cryptographically strong random or pseudorandom number sequence.</p>
									</br>
									<p>In addition, it would be good to keep access token lifetimes short in order to mini- mize the risk associated with the leak of a single access token. This way, even if a token is compromised, its valid lifetime limits its usefulness to the attacker. If a client needs to have longer access to a resource, the authorization server can issue a refresh token to the client.</p>
									</br>
									<p>Refresh tokens are passed between the client and authorization server, but never the protected resource, limiting the attack surface for this style of long- lived token significantly. The definition of what constitutes a &ldquo;short&rsquo; token lifetime depends entirely on the application being protected, but generally speaking, the token shouldn&rsquo;t live much longer than it will be needed for average use of an API.</p>
									</br>
									<p>Ultimately, one of the best things that can be done at the authorization server is pervasive and secure auditing and logging. Whenever a token is issued, consumed, or revoked, the context in which that took place (the client, resource owner, scopes, resource, time, and so on) can be used to watch for suspicious behavior. As a corollary, all of these logs must be kept clear of the access token values to keep them from leaking.</p>
								</br>
								<h6>At the protected resource</h6>
								</br>
									<p>The protected resource often handles access tokens in a way similar to that of the authorization server, and should be treated with the same care for security. Since there are likely to be more protected resources than authorization servers on a network, perhaps even more direct care should be given.</p>
									</br>
									<p>After all, if you&rsquo;re using bearer tokens, there is nothing stopping a malicious protected resource from replaying an access token to other protected resources. Keep in mind that access tokens can inadvertently leak in system logs, especially those that capture all incoming HTTP traffic for analysis. Tokens should be scrubbed from such logs so that the token value isn&rsquo;t used there.</p>
									</br>
									<p>A resource endpoint should be designed to limit token scope, respecting the col- lection minimization principle and asking only for the minimum set of scopes needed to handle a particular job. Although it&rsquo;s the clients that request the scopes associated with a token, designers of protected resources can protect the ecosystem by requiring tokens with only the most specific set of scopes possible for functionality. This part of the design process partitions the application&rsquo;s resources in logical ways such that a client won&rsquo;t need to ask for more functionality than necessary in order to do its job.</p>
									</br>
									<p>The resource server should also properly validate the token and avoid the use of special-purpose access tokens that have some sort of super power.2 Although it&rsquo;s com- mon for a protected resource to cache the current status of a token, especially when using a protocol such as token introspection, the protected resource must always weigh the benefits and drawbacks of such a cache. It&rsquo;s also a good idea to use rate limiting and other techniques to protect the API, which help prevent attackers from fishing for valid tokens at the protected resource.</p>
									</br>
									<p>Keeping access tokens in transient memory is something that will help out in case of attacks against the resource server&rsquo;s data store. This will make it more difficult for an attacker to discover valid access tokens by attacking a back-end system. Granted, in these cases, the attacker will likely have access to the data being protected by the resource, so as always the costs and benefits need to be balanced.</p>
								</br>
							<h5>Authorization code</h5>
							</br>
							</br>
						</div>
				</div>
		</div>
	</div>
</div>
