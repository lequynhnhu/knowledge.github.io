<div class="row mt-5 mb-5">
	<div class="col-12">
		<div class="card" id="card">
			<div class="card-body" id="card-body">
				<div class="d-sm-flex justify-content-between align-items-center">
					<h1 class="header-title mb-0">The Type System</h1>
				</div>
				<div class="market-status-table mt-4">
					<br/>
					<p>In general, a type system assigns a type to each variable, expression, object, function, class, or module in the system. These types are used alongside a set of rules designed to expose errors in the program. These checks can be performed at compile time (static checking) or at runtime (dynamic checking). Typical rules would include ensuring that the value used in an assignment is the same type as the variable it is being assigned to, or ensuring that a function call supplies arguments of the correct type based on the function signature.</p>
					<br/>
					<h5>Optional Static Types</h5>
						<p>JavaScript is dynamically typed; variables do not have a fixed type, so no type restrictions can be applied to operations. You can assign a value of one type to a variable and later assign a value of a completely different type to the same variable. You can perform an operation with two incompatible values and get unpredictable results. If you call a function, there is nothing to enforce that you pass arguments of the correct type and you can even supply too many or too few arguments.</p>
						<p>TypeScript provides a system for inferring and specifying types, but allows types to be optional. The optionality is important because it means you can choose when to enforce types and when to allow dynamic types. Unless you opt out of type checking, using the any type, the compiler will attempt to determine the types in your program and will check inferred types as well as the explicit types you specify using type annotations.</p>
						<p>All the checks are performed at compile time, which is what makes TypeScript statically typed. The compiler is responsible for constructing a schedule of all the types, checking expressions against these types and removing all the type information when it converts the code into valid JavaScript.</p>
					<br/>
					<h5>Structural Typing</h5>
						<p>TypeScript has a structural type system; this contrasts with most C-like languages, which are typically nominative. A nominative, or nominal, type system relies on explicitly named annotations to determine types. In a nominal system, a class would only be seen to implement an interface if it was decorated with the name of the interface (i.e., it must explicitly state that it implements the interface). In a structural type system, the explicit decoration is not required and a value is acceptable as long as its structure matches the specification of the required type.</p>
						<br/>
						<p>A nominal type system is intended to prevent accidental type equivalence &mdash; just because something has the same properties does not mean it is valid &mdash; but as TypeScript is structurally typed accidental type equivalence is possible, and desirable.</p>
						<br/>
						<p>property with an equivalent type would be acceptable. If you wanted to use custom types for this kind of type safety in TypeScript, you would have to ensure the types were not accidentally equivalent by making them structurally unique. It is possible to do this using private members on a class to make it structurally unmatchable,</p>
						<br/>
						<p>While structural typing may seem to cause difficulties in a limited number of specialized situations, it has many advantages. For example, it is far easier to introduce compatible types without having to change existing code, and it is possible to create types that can be passed to external code without inheriting from an external class. It also outperforms nominal types in its ability to introduce a new supertype without changing the newly demoted subtypes, or the code that interacts with them.</p>
						<p>One of the most significant benefits of structural typing is it saves myriad explicit type name decorations. It is possible to implement an interface without adding a specific type annotation, and anonymous objects can be created to match interfaces and classes without the need to add type annotations. You can use these objects if the properties and methods are of the same type, or compatible types, as the required type. A compatible type can be a subtype, a narrower type, or a structurally similar type.</p>
						<br/>
						<p>One thing to avoid in a structurally typed language, such as TypeScript, is empty structures. An empty interface or an empty class is essentially a valid supertype of practically everything in your program, which means any object could be substituted for the empty structure at compile time because there is no contract to satisfy during type checking.</p>
						<p>Structural typing complements the type inference in TypeScript. With these features, you can leave much of the work to the compiler and language service, rather than having to explicitly add type information and class heritage throughout your program.</p>
						<br/>
					<h5>Optional Static Types</h5>
						<br/>
						<p>When you compile your TypeScript program into plain JavaScript, the generated code is different in two ways: code transformation and type erasure. The code transformation converts language features that are not available in the target JavaScript version into representations that are valid.</p>
						<p>For example, if you are targeting ECMAScript 5, where classes are not available, all your classes will be converted into immediately invoked function expressions that create appropriate representations using the prototypal inheritance available in ECMAScript 5. Type erasure is</p>
						<p>Type erasure removes type annotations, custom types, and interfaces. These are only required at design time and at compile time for the purpose of static checking. At runtime types are not checked so the type information is not needed. You shouldn&rsquo;t encounter a problem at runtime because the logical use of types has been checked, except where you have opted out by using the "any" type.</p>
						<br/>
					<h5>Type Inference</h5>
						<br/>
						<p>Type inference is the polar opposite of type erasure. Type inference is the process by which types are determined at compile time in the absence of explicit type annotations.</p>
						<p>TypeScript performs deep inspections to create a schedule of types in your program and compares assignments, expressions, and operations using this schedule of types. During this process, there are some clever tricks that are employed when a direct type is not available, which allow the type to be found indirectly. One such trick is contextual typing, where TypeScript uses the context of an expression to determine the types.</p>
						<br/>
						<h6>a. Best Common Type</h6>
							<br/>
								<p>When type information is being inferred, there are a limited number of situations where the best common type must be determined.</p>
								<p>The process of determining the best common type is not just used for array literal expressions; they also are used to determine any case where multiple values have different types, such as the return type of a function or method that contains multiple return statements.</p>
								<br/>
								<p>// number[]<br />let x = [0, 1, null];</p>
								<p><br />// (string | number)[]<br />let y = [0, 1, null, 'a'];</p>
							<br/>
						<h6>b. Contextual Types</h6>
							<br/>
							<p>Contextual types are a good example of how advanced type inference can be. Contextual typing occurs when the compiler bases its types on the location of an expression.</p>
							<p>window.onclick = function(event) {<br />var button = event.button;<br />};</p>
							<br/>
						<h6>c. Widened Types</h6>
							<br/>
							<p>The term &ldquo;widened type&rdquo; refers to situations in TypeScript where the type of a function call, expression, or assignment is null or undefined.</p>
							<p>function example() {<br />return null;<br />}<br />var widened = example ();</p>
							<br/>
						<h6>When to Annotate</h6>
							<br/>
							<p>Because type inference has been a key feature of TypeScript since day one, the discussion on when to make types explicit with type annotations can take place without controversy. This has been a tricky topic for statically typed languages that have later decided to add some level of support for type inference.</p>
							<p>The final decision about the level of type annotations you add to your program should be made jointly between all team members, but you may wish to use the following suggestions as a starting point for your discussion.</p>
								<p>&bull; Start by adding no type annotations (full inference.)</p>
								<p>&bull; Add type annotations where the inferred type would be any.</p>
								<p>&bull; Add type annotations for public method return types.</p>
								<p>&bull; Add type annotations for public method parameters.</p>
							<br/>
					<h5>Duplicate Identifiers</h5>
						<br/>
							<p>Overall, you should do your best to avoid name clashes in your program. TypeScript supplies the tools to make name clashes unnecessary by allowing you to move your program out of the global scope and into modules. However, there are some interesting features around identifiers in TypeScript, including many situations where you are permitted to use the same name within the same scope.</p>
							<p>In most cases, the use of an existing class or variable name within the same scope will result in a &ldquo;Duplicate identifier&rdquo; error. No particular structure gets preferential treatment; the latter of the two identifiers will be the source of the error. If you re-use a namespace multiple times in your program, this will not result in a duplicate identifier error because all of the individual blocks are logically merged into a single namespace.</p>
							<p>Another valid use of a duplicate identifier is with interfaces. Once again, the compiler knows that there will be no duplicate identifier at runtime because interfaces are erased during compilation; its identifier will never appear in the JavaScript output. The use of a duplicate identifier for an interface and a variable is a common pattern in the TypeScript library, where the standard types are defined using an interface and then allocated to a variable declaration with a type annotation.</p>
						<br/>
					<h5>Type Checking</h5>
						<br/>
						<p>Once a schedule of types has been gathered from your program, the TypeScript compiler is able to use this schedule to perform type checking. At its simplest, the compiler is checking that when a function is called that accepts a parameter of type "number"; all calling code passes an argument with a type that is compatible with the "number" type.</p>
						<p>Type checking is not limited to positive matching, where the supplied type must have the structure of the required type. An increasing number of negative checks are being added to the compiler that enables it to detect a different class of error.</p>
						<p>For example, the excess property warning will highlight properties that are not anticipated on an object, which is a great way to catch situations where you have mis-typed a property name. This kind of checking may introduce additional errors as you upgrade the version of TypeScript you use in your projects, but if you persevere and review the messages the compiler is sending you, you will eventually find subtle bugs that the compiler has managed to catch for you.</p>
						<br/>
					<h5>Ambient Declarations</h5>
						<br/>
						<p>Ambient declarations can be used to add type information to existing JavaScript code. Commonly, this is used to add type information for your own existing code, or for a third-party library that you want to consume in your TypeScript program.</p>
						<p>Ambient declarations can be gradually constructed by starting with a simple imprecise declaration and turning up the dial on the details over time.&nbsp;</p>
						<br/>
						<p>declare var $: any;<br />$('#id').html('Hello World');</p>
						<br/>
						<p> => shows an example of the least precise ambient<br />declaration you can write for the jQuery framework. The declaration simply notifies the compiler that an external variable will exist at runtime without supplying further details of the structure of the external variable. This will suppress errors for the $ variable, but will not supply deep type checking or useful autocompletion.</p>
						<br/>
						<p>All ambient declarations begin with the declare keyword. This tells the compiler that the following code block contains only type information and no implementation. Blocks of code created using the declare keyword will be erased during compilation and result in no JavaScript output. At runtime, you are responsible for ensuring the code exists and that it matches your declaration.</p>
						<p>To get the full benefit of compile-time checking, you can create a more detailed ambient declaration that covers more of the features of the external JavaScript that you use. If you are building an ambient declaration, you can choose to cover the features you use the most, or the higher-risk features that you judge to be the most likely source of type errors. This allows you to invest in defining the type information that gives you the most return on your time investment.</p>
						<br/>
						<p>It is possible to create ambient declarations for variables, functions, classes, enumerations, and both internal and external modules. Interfaces appear to be missing from this list, but interfaces are already analogous to ambient declarations as they describe a type without resulting in any compiled code. This means you can write ambient declarations using interfaces, but you would not use the declare keyword for interfaces.</p>
				</div>
			</div>
		</div>
	</div>
</div>
