<div class="row mt-5 mb-5">
	<div class="col-12">
		<div class="card" id="card">
				<div class="card-body" id="card-body">
						<div class="d-sm-flex justify-content-between align-items-center">
							<h1 class="header-title mb-0">Enumerations & Autoboxing & Annotations</h1>
						</div>
						<div class="market-status-table mt-4">
							<h5>Enumerations & Autoboxing</h5>
								</br>
								<p>In its simplest form, an enumeration is a list of named constants that define a new data type and its legal values. Thus, an enumeration object can hold only a value that was declared in the list. Other values are not allowed. In other words, an enumeration gives you a way to explicitly specify the only values that a data type can legally have. Enumerations are commonly used to define a set of values that represent a collection of items.</p>
								</br>
								<p>Java has included two important features: autoboxing and auto-unboxing. Autoboxing is the process by which a primitive type is automatically encapsulated (boxed) into its equivalent type wrapper whenever an object of that type is needed.</p>
								<p>There is no need to explicitly construct an object. Auto-unboxing is the process by which the value of a boxed object is automatically extracted (unboxed) from a type wrapper when its value is needed.</p>
							</br>
							<h5>Annotations></h5>
								</br>
								<p>Java provides a feature that enables you to embed supplemental information into a source file. This information, called an annotation, does not change the actions of a program. Thus, an annotation leaves the semantics of a program unchanged. However, this information can be used by various tools during both development and deployment.</p>
								</br>
								<p>For example, an annotation might be processed by a source-code generator. The term metadata is also used to refer to this feature, but the term annotation is the most descriptive and more commonly used.</p>
								</br>
								<p>An annotation with a retention policy of <strong>SOURCE</strong> is retained only in the source file and is discarded during compilation.</p>
								</br>
								<p>An annotation with a retention policy of <strong>CLASS</strong> is stored in the .class file during compilation. However, it is not available through the JVM during run time.</p>
								</br>
								<p>An annotation with a retention policy of <strong>RUNTIME</strong> is stored in the .class file during compilation and is available through the JVM during run time. Thus, RUNTIME retention offers the greatest annotation persistence.</p>
								</br>
								<h6>Obtaining Annotations at Run Time by Use of Reflection</h6>
								</br>
									<p>Although annotations are designed mostly for use by other development or deployment tools, if they specify a retention policy of RUNTIME, then they can be queried at run time by any Java program through the use of reflection. Reflection is the feature that enables information about a class to be obtained at run time.</p>
									<p><strong>Notice</strong> the &lt;?&gt; that follows Class in the declaration of getClass( ) just shown. This is related to Java&rsquo;s generics feature. getClass( ) and several other reflection-related methods discussed in this chapter make use of generics.</p>
								</br>
								<h6>Some Restrictions</h6>
								</br>
									<p>First, no annotation can inherit another. Second, all methods declared by an annotation must be without parameters. Furthermore, they must return one of the following:</p>
									<p>&bull; A primitive type, such as int or double</p>
									<p>&bull; An object of type String or Class<br /> &bull; An object of an enum type<br /> &bull; An object of another annotation type</p>
									<p>&bull; An array of a legal type.</p>
								</br>
						</div>
				</div>
		</div>
	</div>
</div>
<div class="row mt-5 mb-5">
	<div class="col-12">
		<div class="card" id="card">
				<div class="card-body" id="card-body">
						<div class="d-sm-flex justify-content-between align-items-center">
							<h1 class="header-title mb-0">I/O, Try-with-Resources</h1>
						</div>
						<div class="market-status-table mt-4">
							<h5>Streams</h5>
							</br>
								<p>A stream is an abstraction that either produces or consumes information. A stream is linked to a physical device by the Java I/O system. All streams behave in the same manner, even if the actual physical devices to which they are linked differ. Thus, the same I/O classes and methods can be applied to different types of devices.</p>
								</br>
								<p>This means that an input stream can abstract many different kinds of input: from a disk file, a keyboard, or a network socket. Likewise, an output stream may refer to the console, a disk file, or a network connection. Streams are a clean way to deal with input/output without having every part of your code understand the difference between a keyboard and a network.</p>
								</br>
								<h6>Byte Streams and Character Streams</h6>
								</br>
								<p>Java defines two types of streams: byte and character. Byte streams provide a convenient means for handling input and output of bytes. Byte streams are used, for example, when reading or writing binary data.</p>
								<p>Character streams provide a convenient means for handling input and output of characters. They use Unicode and, therefore, can be internationalized. Also, in some cases, character streams are more efficient than byte streams.</p>
							</br>
						</div>
				</div>
		</div>
	</div>
</div>
