<div class="row mt-5 mb-5">
	<div class="col-12">
		<div class="card" id="card">
				<div class="card-body" id="card-body">
						<div class="d-sm-flex justify-content-between align-items-center">
							<h1 class="header-title mb-0">Javaâ€™s Magic: The Bytecode</h1>
						</div>
						<div class="market-status-table mt-4">
							<p>Bytecode is a highly optimized set of instructions designed to be executed by what is called the Java Virtual Machine (JVM), which is part of the Java Runtime Environment (JRE). In essence, the original JVM was designed as an interpreter for bytecode.&nbsp;</p>
							</br>
							<p>Translating a Java program into bytecode makes it much easier to run a program in a wide variety of environments because only the JVM needs to be implemented for each platform. Once a JRE exists for a given system, any Java program can run on it.</p>
							</br>
							<p>Remember, although the details of the JVM will differ from platform to platform, all understand the same Java bytecode. If a Java program were compiled to native code, then different versions of the same program would have to exist for each type of CPU connected to the Internet.</p>
							</br>
							<p>The fact that a Java program is executed by the JVM also helps to make it secure. Because the JVM is in control, it manages program execution. Thus, it is possible for the JVM to create a restricted execution environment, called the sandbox, that contains the program, preventing unrestricted access to the machine. Safety is also enhanced by certain restrictions that exist in the Java language.</p>
							</br>
							<p>Although Java was designed as an interpreted language, there is nothing about Java that prevents on-the-fly compilation of bytecode into native code in order to boost performance. For this reason, the HotSpot technology was introduced not long after Java&rsquo;s initial release. HotSpot provides a Just-In-Time (JIT) compiler for bytecode.</p>
							</br>
							<p>When a JIT compiler is part of the JVM, selected portions of bytecode are compiled into executable code in real time, on a piece-by-piece, demand basis. It is important to understand that an entire Java program is not compiled into executable code all at once. Instead, a JIT compiler compiles code as it is needed, during execution.</p>
							</br>
							<p>Furthermore, not all sequences of bytecode are compiled&mdash;only those that will benefit from compilation. The remaining code is simply interpreted. However, the just-in- time approach still yields a significant performance boost. Even when dynamic compilation is applied to bytecode, the portability and safety features still apply, because the JVM is still in charge of the execution environment.</p>
							</br>
							<p>One other point: Beginning with JDK 9, some Java environments will also support an ahead-of-time compiler that can be used to compile bytecode into native code prior to execution by the JVM, rather than on-the-fly. Ahead-of- time compilation is a specialized feature, and it does not replace Java&rsquo;s traditional approach just described.</p>
							<h4>The Java Buzzwords</h4>	
							</br>
								<h5>Object-Oriented</h5>
								</br>
									<p>Although influenced by its predecessors, Java was not designed to be source- code compatible with any other language. This allowed the Java team the freedom to design with a blank slate. One outcome of this was a clean, usable, pragmatic approach to objects. Borrowing liberally from many seminal object- software environments of the last few decades, Java manages to strike a balance between the purist&rsquo;s &ldquo;everything is an object&rdquo; paradigm and the pragmatist&rsquo;s &ldquo;stay out of my way&rdquo; model. The object model in Java is simple and easy to extend, while primitive types, such as integers, are kept as high- performance nonobjects.</p>
								<h5>Robust</h5>
								</br>
									<p>To better understand how Java is robust, consider two of the main reasons for program failure: memory management mistakes and mishandled exceptional conditions (that is, run-time errors). Memory management can be a difficult, tedious task in traditional programming environments. For example, in C/C++, the programmer will often manually allocate and free dynamic memory.</p>
									</br>
									<p>This sometimes leads to problems, because programmers will either forget to free memory that has been previously allocated or, worse, try to free some memory that another part of their code is still using. Java virtually eliminates these problems by managing memory allocation and deallocation for you. (In fact, deallocation is completely automatic, because Java provides garbage collection for unused objects.)</p>
									</br>
									<p>Exceptional conditions in traditional environments often arise in situations such as division by zero or &ldquo;file not found,&rdquo; and they must be managed with clumsy and hard-to-read constructs. Java helps in this area by providing object-oriented exception handling. In a well-written Java program, all run-time errors can&mdash;and should&mdash;be managed by your program.</p>
									</br>
								<h5>Multithreaded</h5>
								</br>
									<p>Java was designed to meet the real-world requirement of creating interactive, networked programs. To accomplish this, Java supports multithreaded programming, which allows you to write programs that do many things simultaneously. The Java run-time system comes with an elegant yet sophisticated solution for multiprocess synchronization that enables you to construct smoothly running interactive systems.</p>
								<h5>Interpreted and High Performance</h5>
								</br>
									<p>Java enables the creation of cross-platform programs by compiling into an intermediate representation called Java bytecode. This code can be executed on any system that implements the Java Virtual Machine. Most previous attempts at cross-platform solutions have done so at the expense of performance. As explained earlier, the Java bytecode was carefully designed so that it would be easy to translate directly into native machine code for very high performance by using a just-in-time compiler. Java run-time systems that provide this feature lose none of the benefits of the platform-independent code.</p>
									</br>
								<h5>Distributed</h5>
								</br>
									<p>Java is designed for the distributed environment of the Internet because it handles TCP/IP protocols. In fact, accessing a resource using a URL is not much different from accessing a file. Java also supports Remote Method Invocation (RMI). This feature enables a program to invoke methods across a network.</p>
								</br>
								<h5>Dynamic</h5>
								</br>
									<p>Java programs carry with them substantial amounts of run-time type information that is used to verify and resolve accesses to objects at run time. This makes it possible to dynamically link code in a safe and expedient manner. This is crucial to the robustness of the Java environment, in which small fragments of bytecode may be dynamically updated on a running system.</p>
							</br>
						</div>
				</div>
		</div>
	</div>
</div>
<div class="row mt-5 mb-5">
	<div class="col-12">
		<div class="card" id="card">
				<div class="card-body" id="card-body">
						<div class="d-sm-flex justify-content-between align-items-center">
							<h1 class="header-title mb-0">Object-Oriented Programming</h1>
						</div>
						<div class="market-status-table mt-4">
							</br>
								<p>All computer programs consist of two elements: code and data. Furthermore, a program can be conceptually organized around its code or around its data. That is, some programs are written around &ldquo;what is happening&rdquo; and others are written around &ldquo;who is being affected.&rdquo;</p>
								</br>
								<p>These are the two paradigms that govern how a program is constructed. The first way is called the process- oriented model. This approach characterizes a program as a series of linear steps (that is, code). The process-oriented model can be thought of as code acting on data.</p>
								</br>
								<p>To manage increasing complexity, the second approach, called object- oriented programming, was conceived. Object-oriented programming organizes a program around its data (that is, objects) and a set of well-defined interfaces to that data. An object-oriented program can be characterized as data controlling access to code. As you will see, by switching the controlling entity to data, you can achieve several organizational benefits.</p>
								<h5>Abstraction</h5>
									<p>An essential element of object-oriented programming is abstraction. Humans manage complexity through abstraction.</p>
									</br>
									<p>For example, people do not think of a car as a set of tens of thousands of individual parts. They think of it as a well- defined object with its own unique behavior. This abstraction allows people to use a car to drive to the grocery store without being overwhelmed by the complexity of the individual parts. They can ignore the details of how the engine, transmission, and braking systems work. Instead, they are free to utilize the object as a whole.</p>
									</br>
									<p>A powerful way to manage abstraction is through the use of hierarchical classifications. This allows you to layer the semantics of complex systems, breaking them into more manageable pieces.</p>
									</br>
									<p>Hierarchical abstractions of complex systems can also be applied to computer programs. The data from a traditional process-oriented program can be transformed by abstraction into its component objects. A sequence of process steps can become a collection of messages between these objects.</p>
									</br>
									<p>Thus, each of these objects describes its own unique behavior. You can treat these objects as concrete entities that respond to messages telling them to do something. This is the essence of object-oriented programming.</p>
									</br>
									<p>Object-oriented concepts form the heart of Java just as they form the basis for human understanding. It is important that you understand how these concepts translate into programs. As you will see, object-oriented programming is a powerful and natural paradigm for creating programs that survive the inevitable changes accompanying the life cycle of any major software project, including conception, growth, and aging. For example, once you have well- defined objects and clean, reliable interfaces to those objects, you can gracefully decommission or replace parts of an older system without fear.</p>
									</br>
								<h5>The Three OOP Principles</h5>
								</br>
									<h6>Encapsulation</h6>
									</br>
										<p>Encapsulation is the mechanism that binds together code and the data it manipulates, and keeps both safe from outside interference and misuse. One way to think about encapsulation is as a protective wrapper that prevents the code and data from being arbitrarily accessed by other code defined outside the wrapper. Access to the code and data inside the wrapper is tightly controlled through a well-defined interface.</p>
										</br>
										<p>To relate this to the real world, consider the automatic transmission on an automobile. It encapsulates hundreds of bits of information about your engine, such as how much you are accelerating, the pitch of the surface you are on, and the position of the shift lever.</p>
										</br>
										<p>You, as the user, have only one method of affecting this complex encapsulation: by moving the gear-shift lever. You can&rsquo;t affect the transmission by using the turn signal or windshield wipers, for example. Thus, the gear-shift lever is a well-defined (indeed, unique) interface to the transmission. Further, what occurs inside the transmission does not affect objects outside the transmission.</p>
										</br>
									<h6>Inheritance</h6>
									</br>
										<p>Inheritance is the process by which one object acquires the properties of another object. This is important because it supports the concept of hierarchical classification. As mentioned earlier, most knowledge is made manageable by hierarchical (that is, top-down) classifications.</p>
									</br>
									<h6>Polymorphism</h6>
									</br>
									<p>Polymorphism (from Greek, meaning &ldquo;many forms&rdquo;) is a feature that allows one interface to be used for a general class of actions. The specific action is determined by the exact nature of the situation.</p>
							</br>
						</div>
				</div>
		</div>
	</div>
</div>
