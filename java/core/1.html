<div class="row mt-5 mb-5">
	<div class="col-12">
		<div class="card" id="card">
				<div class="card-body" id="card-body">
						<div class="d-sm-flex justify-content-between align-items-center">
							<h1 class="header-title mb-0">Javaâ€™s Magic: The Bytecode</h1>
						</div>
						<div class="market-status-table mt-4">
							<p>Bytecode is a highly optimized set of instructions designed to be executed by what is called the Java Virtual Machine (JVM), which is part of the Java Runtime Environment (JRE). In essence, the original JVM was designed as an interpreter for bytecode.&nbsp;</p>
							</br>
							<p>Translating a Java program into bytecode makes it much easier to run a program in a wide variety of environments because only the JVM needs to be implemented for each platform. Once a JRE exists for a given system, any Java program can run on it.</p>
							</br>
							<p>Remember, although the details of the JVM will differ from platform to platform, all understand the same Java bytecode. If a Java program were compiled to native code, then different versions of the same program would have to exist for each type of CPU connected to the Internet.</p>
							</br>
							<p>The fact that a Java program is executed by the JVM also helps to make it secure. Because the JVM is in control, it manages program execution. Thus, it is possible for the JVM to create a restricted execution environment, called the sandbox, that contains the program, preventing unrestricted access to the machine. Safety is also enhanced by certain restrictions that exist in the Java language.</p>
							</br>
							<p>Although Java was designed as an interpreted language, there is nothing about Java that prevents on-the-fly compilation of bytecode into native code in order to boost performance. For this reason, the HotSpot technology was introduced not long after Java&rsquo;s initial release. HotSpot provides a Just-In-Time (JIT) compiler for bytecode.</p>
							</br>
							<p>When a JIT compiler is part of the JVM, selected portions of bytecode are compiled into executable code in real time, on a piece-by-piece, demand basis. It is important to understand that an entire Java program is not compiled into executable code all at once. Instead, a JIT compiler compiles code as it is needed, during execution.</p>
							</br>
							<p>Furthermore, not all sequences of bytecode are compiled&mdash;only those that will benefit from compilation. The remaining code is simply interpreted. However, the just-in- time approach still yields a significant performance boost. Even when dynamic compilation is applied to bytecode, the portability and safety features still apply, because the JVM is still in charge of the execution environment.</p>
							</br>
							<p>One other point: Beginning with JDK 9, some Java environments will also support an ahead-of-time compiler that can be used to compile bytecode into native code prior to execution by the JVM, rather than on-the-fly. Ahead-of- time compilation is a specialized feature, and it does not replace Java&rsquo;s traditional approach just described.</p>
							<h4>The Java Buzzwords</h4>	
							</br>
								<h5>Object-Oriented</h5>
								</br>
									<p>Although influenced by its predecessors, Java was not designed to be source- code compatible with any other language. This allowed the Java team the freedom to design with a blank slate. One outcome of this was a clean, usable, pragmatic approach to objects. Borrowing liberally from many seminal object- software environments of the last few decades, Java manages to strike a balance between the purist&rsquo;s &ldquo;everything is an object&rdquo; paradigm and the pragmatist&rsquo;s &ldquo;stay out of my way&rdquo; model. The object model in Java is simple and easy to extend, while primitive types, such as integers, are kept as high- performance nonobjects.</p>
								<h5>Robust</h5>
								</br>
									<p>To better understand how Java is robust, consider two of the main reasons for program failure: memory management mistakes and mishandled exceptional conditions (that is, run-time errors). Memory management can be a difficult, tedious task in traditional programming environments. For example, in C/C++, the programmer will often manually allocate and free dynamic memory.</p>
									</br>
									<p>This sometimes leads to problems, because programmers will either forget to free memory that has been previously allocated or, worse, try to free some memory that another part of their code is still using. Java virtually eliminates these problems by managing memory allocation and deallocation for you. (In fact, deallocation is completely automatic, because Java provides garbage collection for unused objects.)</p>
									</br>
									<p>Exceptional conditions in traditional environments often arise in situations such as division by zero or &ldquo;file not found,&rdquo; and they must be managed with clumsy and hard-to-read constructs. Java helps in this area by providing object-oriented exception handling. In a well-written Java program, all run-time errors can&mdash;and should&mdash;be managed by your program.</p>
									</br>
								<h5>Multithreaded</h5>
								</br>
									<p>Java was designed to meet the real-world requirement of creating interactive, networked programs. To accomplish this, Java supports multithreaded programming, which allows you to write programs that do many things simultaneously. The Java run-time system comes with an elegant yet sophisticated solution for multiprocess synchronization that enables you to construct smoothly running interactive systems.</p>
								<h5>Interpreted and High Performance</h5>
								</br>
									<p>Java enables the creation of cross-platform programs by compiling into an intermediate representation called Java bytecode. This code can be executed on any system that implements the Java Virtual Machine. Most previous attempts at cross-platform solutions have done so at the expense of performance. As explained earlier, the Java bytecode was carefully designed so that it would be easy to translate directly into native machine code for very high performance by using a just-in-time compiler. Java run-time systems that provide this feature lose none of the benefits of the platform-independent code.</p>
									</br>
								<h5>Distributed</h5>
								</br>
									<p>Java is designed for the distributed environment of the Internet because it handles TCP/IP protocols. In fact, accessing a resource using a URL is not much different from accessing a file. Java also supports Remote Method Invocation (RMI). This feature enables a program to invoke methods across a network.</p>
								</br>
								<h5>Dynamic</h5>
								</br>
									<p>Java programs carry with them substantial amounts of run-time type information that is used to verify and resolve accesses to objects at run time. This makes it possible to dynamically link code in a safe and expedient manner. This is crucial to the robustness of the Java environment, in which small fragments of bytecode may be dynamically updated on a running system.</p>
							</br>
							
						</div>
				</div>
		</div>
	</div>
</div>
